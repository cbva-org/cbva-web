using extension pg_trgm;
using extension pgcrypto;

module default {
    # Style notes
    # Arrow syntax (->) isn't required, but used on links
    # 'link' / 'property' qualifiers should be avoided unless necessary

    global user: uuid;

    abstract type HasCreated {
        required created: datetime {
            default := datetime_of_statement();
            readonly := true;
        }
    }

    scalar type Gender extending enum<Male, Female, Coed>;
    scalar type TShirtSize extending enum<S, M, L, XL>;

    scalar type Rating extending enum<Novice, Unrated, B, A, AA, AAA>;
    scalar type Division extending enum<
            Unrated, B, A, AA, AAA, Open,
            U12, U14, U16, U18>;

    # TODO: this function should be updated whenever the juniors divisions cutoffs should best
    #       updated. It was an oversite to hard code the years in here. Ideally, this can be calculated
    #       on the fly.
    function valid_juniors_divisions(grad_year: optional int16) -> set of Division
        using (
            with
                base_division := (
                    if grad_year >= 2032 then Division.U12
                    else if grad_year >= 2030 then Division.U14
                    else if grad_year >= 2028 then Division.U16
                    else if grad_year >= 2026 then Division.U18
                    else {}
                ),
                u12_valid_divisions := { Division.U12, Division.U14, Division.U16, Division.U18 },
                u14_valid_divisions := { Division.U14, Division.U16, Division.U18 },
                u16_valid_divisions := { Division.U16, Division.U18 },
                u18_valid_divisions := { Division.U18 },
                valid_divisions := (
                    if base_division = Division.U12 then u12_valid_divisions
                    else if base_division = Division.U14 then u14_valid_divisions
                    else if base_division = Division.U16 then u16_valid_divisions
                    else if base_division = Division.U18 then u18_valid_divisions
                    else {}
                )
            select
                valid_divisions
        );

    type Settings {
        required year: int16;
        required is_primary: bool {
            constraint exclusive;
        }
        membership_fee: float32;
        required withdrawal_fee: float32;
        cal_cup_first_cutoff: int16;
        cal_cup_second_cutoff: int16;
        cal_cup_name: str;
    }

    type User extending HasCreated {
        index ext::pg_trgm::gist on (.search_helper);

        required search_helper: str {
            rewrite insert, update using (.legal_name ++ ' ' ++ .first_name ++ ' ' ++ .last_name ++ ' ' ++ .username);
        }

        required permissions: int32 {
            default := 0;
        }
        required has_migrated: bool {
            # Whether they have logged in yet on the new site
            # This "migrated" refers to completing that login & data check
            # The SQL -> edgedb migration explicitly sets false here
            default := true;
        }

        required active: bool {
            default := false;
        }
        index on (.active);

        admin_username_bypass: str; # If matches username overrides 8 char minimum

        # Prevent user from changing username, eg if abused
        required admin_username_lock: bool {
            default := false
        }
        required username: str {
            # Autogenerated for legacy users
            constraint exclusive;
            constraint max_len_value(24);
            rewrite insert, update using (str_lower(str_trim(.username, '.:/- ')));
        }
        trigger prohibit_locked_change after update for each
            when (__old__.username != __new__.username)
            do (
                assert(
                    not __new__.admin_username_lock,
                    message := "Username locked",
                )
            );

        required legal_name: str {
            constraint max_len_value(80);
        }
        # "Display name"
        # UI shows example bracket card
        # Eg Dalhausser / de los Rios vs Benesh / Partain
        # As they update first/last
        required first_name: str {
            constraint max_len_value(30);
            rewrite insert, update using (str_trim(.first_name, '.:/- '));
        }
        required last_name: str {
            constraint max_len_value(50);
            rewrite insert, update using (str_trim(.last_name, '.:/- '));
        }
        avp_id: int32 {
            constraint exclusive;
        }
        legacy_id: int32 {
            constraint exclusive;
        }
        customer_key: str;

        required gender: Gender {
            constraint one_of (Gender.Male, Gender.Female);
        }
        index on (.gender);
        required birthdate: cal::local_date;
        required email: str {
            constraint max_len_value(80);
            rewrite insert, update using (str_lower(str_trim(.email, '.:/- ')));
        }
        index on (.email);

        required phone: str {
            constraint max_len_value(25);
            rewrite insert, update using (str_trim(.phone, '.:/- '));
        }

        player_phone: str {
            constraint max_len_value(25);
            rewrite insert, update using (str_trim(.player_phone, '.:/- '));
        }

        password_hash: str;

        required country: str {
            constraint max_len_value(50);
        }
        zipcode: str {
            constraint max_len_value(25);
        } # Need to add zipcode constraint relative to country

        required tshirt_size: TShirtSize;
        required got_tshirt: bool {
            default := false;
        }

        high_school_grad_year: int16;

        required rating: Rating {
            default := Rating.Novice;
        }
        required rated_points: float32 {
            default := 0;
        }
        required juniors_points: float32 {
            default := 0;
        }
        required rank: int32 {
            rewrite insert using (max((select User filter .gender = __subject__.gender).rank ?? 0) + 1);
        }
    }

    type PhoneVerification {
        required user -> User  {
            on target delete delete source;
        }

        required phone: str;
    }

    type TShirtPickupVerification extending HasCreated {
        required user -> User  {
            on target delete delete source;
        }

        required year: int16 {
            default := (select Settings.year filter Settings.is_primary limit 1)
        }

        required updated: datetime {
            default := datetime_of_statement()
        }

        constraint exclusive on ((.user, .year))
    }

    type VerifySession {
        # hash generated by ext::pgcrypto::crypt
        required code: str;

        # permissions that might be encoded in metadata_json, kept separately for easy reference.
        permissions: int32;

        # The UserMetadata object json serialized.
        required metadata_json: bytes;

        required tries: int16 {
            default := 0;
        }

        required created: datetime {
            default := datetime_of_statement();
            readonly := true;
        }

        required last_accessed: datetime {
            default := datetime_of_statement();
        }
    }

    type DirectorPreferences {
        required user -> User {
            constraint exclusive;
        }
        # Displayed on tournaments
        # If null, use fields from User
        email: str {
            constraint max_len_value(300);
            rewrite insert, update using (
                with new := str_trim(.email, '.:/- ')
                select new if len(new) > 0 else <str>{});
        }
        phone: str {
            constraint max_len_value(300);
            rewrite insert, update using (
                with new := str_trim(.phone, '.:/- ')
                select new if len(new) > 0 else <str>{});
        }
    }

    scalar type Relationship extending enum<Parent, Guardian, Coach, Friend, Relative, Other>;

    # This & Social could go as an array of tuples
    # But doesn't matter too much
    # This is more extensible, even if it needs a join
    # Not used yet
    type EmergencyContact {
        required name: str {
            constraint max_len_value(80);
        }
        required relationship: Relationship;
        required user -> User {
            on target delete delete source;
        }
        required email: str {
            constraint max_len_value(80);
        }
        required phone: str {
            constraint max_len_value(80);
        }
        required note: str {
            constraint max_len_value(200);
        }
    }

    scalar type Social extending enum<Instagram, Facebook, YouTube, TikTok, Other>;

    # Not used yet
    type SocialLink {
        required social: Social;
        required url: str {
            constraint max_len_value(100);
        }
        required user -> User  {
            on target delete delete source;
        }
    }

    scalar type BeachStatus extending enum<
        Active,

        # Tournaments were held here but not anymore
        # Not shown in list
        # Only shown in search dropdown if specifically searched for
        Legacy,

        # Not shown in list or search unless admin
        Hidden,
    >;

    type Beach {
        # TODO various exclusive constraints, once touched up
        # TODO drop unused (0 tournaments)
        # TODO drop after migrations
        legacy_id: int32 {
            constraint exclusive;
            readonly := true;
        }
        # Eg Ocean Park
        required name: str {
            constraint min_len_value(5);
            constraint max_len_value(54);
        }
        required city: str {
            constraint min_len_value(5);
            constraint max_len_value(54);
        }
        # Eg OP
        required short_name: str {
            constraint exclusive;
            constraint min_len_value(2);
            constraint max_len_value(2);
        }
        # Relative to www.cbva.com/b/, eg hermosa
        required url: str {
            constraint exclusive;
            constraint min_len_value(4);
            constraint max_len_value(38);
        }
        required refund_cutoff: duration {
            default := <duration>'21 hours'
        }
        auto_open: duration;
        required directions: str {
            constraint min_len_value(2);
            constraint max_len_value(2500);
        }
        required description: str {
            constraint min_len_value(2);
            constraint max_len_value(2500);
        }
        required google_maps_link: str {
            constraint min_len_value(2);
            constraint max_len_value(2500);
        }
        required status: BeachStatus;
        required director -> User;
    }

    scalar type TournamentStatus extending enum<
        # Seeding always happens on any roster change
        # TD always has a 'Preview Pools' button but pools aren't made yet
        RosterPrivate,

        # Automatic 9am the day before tournament
        # TDs can toggle between this and private before then
        # Enables button to generate pools
        RosterPublic,

        # Everything implicitly public
        # Registration, pools are fully locked
        # TD can set back to Public if games haven't started
        # Displays sanction info
        Running,

        # Set by finals game being verified
        # Waitlist cleared and refunded
        # Results shown on team list
        Complete,

        # Roster, waitlist cleared and refunded
        Cancelled,

        Schedule
    >;

    scalar type RegistrationStatus extending enum<
        # Shows normally
        # Waitlist will automatically promote teams
        Open,

        # Shows normally but cannot register or waitlist unless invited.
        # Used by Santa Cruz for T-30 days
        # Used by Cal Cup to be qualifier only
        # Otherwise only set manually
        Closed,

        # Specific TD, admin, registered, invited players can still find link easily
        # Direct link to tournament always works
        # This is a subtype of registration because hidden implicitly is also closed
        Hidden,

        # Only visible to admins
        Test,
    >;

    # TODO manually apply these tags
    scalar type TournamentTag extending enum<
        CalCup, # Cal Cup qualifier. Will grant 2x points. TODO constraint is on juniors
        BigMoney,
        # "Recreational"/"Competitive" is whether requirements exists or not
        # "Fours" is team_size
        # "AVP Wildcard" is from its other object
    >;

    # A legacy tournament is this with no games, pools linked
    # Teams are still there and have the required metadata
    type Tournament extending HasCreated {
        # TODO drop after migrations
        legacy_id: int32 {
            constraint exclusive;
        }
        bonus_points: int32;
        point_factor: int32;

        schedule_template -> Tournament;
        required start_at: datetime;
        # Unclear if these indices do anything
        index on (.start_at);
        index on (datetime_get(.start_at, 'day'));
        index on (datetime_get(.start_at, 'month'));
        index on (datetime_get(.start_at, 'year'));

        # Should only be set if special name
        # Though many juniors will be "AVP Bid Event"
        # Use is name + gender + division for display
        # As such, should not include gender or division
        name: str {
            constraint max_len_value(100);
            rewrite insert, update using (
                with new := str_trim(str_replace(.name, '  ', ' '), '.:/- ')
                select new if len(new) > 0 else <str>{});
        }

        required url: str {
            readonly := true;
            constraint exclusive;
            constraint min_len_value(8);
            constraint max_len_value(8);
            rewrite insert using (
                with letters := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'
                select to_str(array_agg((for _ in range_unpack(range(0, 8)) union (
                        letters[<int64>math::floor(random() * 1000 % len(letters))])
                    )), '')
            );
        }

        # The annual schedule is made up of these with status = Schedule
        # Admin will have a button to clone schedule into year's tournaments
        # Hidden tournaments can only be viewed by admins or TD
        # There is no deletion
        required status: TournamentStatus;
        index on (.status);
        required registration: RegistrationStatus;
        index on (.registration);
        required fee: float32; # Cost per team to enter

        required division: Division;
        index on (.division);
        required gender: Gender;
        index on (.gender);

        required team_size: int16 {
            default := 2;
        }

        custom_format: str {
            constraint max_len_value(1000);
        }

        # If set this is a "rec" tournament
        # All requirments must be fulfilled
        # Rated division check is done by the overall division
        # Juniors division check requires sufficient players
        # Eg a coed AA tournament would have
        # [{ minimum: 1, gender: Female, division: AA },
        #  { minimum: 1, gender: Male, division: AA }]
        # Eg a 4's A team could have team_size 4 and
        # [{ minimum: 1, gender: Female, division: A },
        #  { minimum: 1, gender: Male, division: A }]
        # Or a Father/Daughter 14u team would have
        # [{ minimum: 1, gender: Female, division: 14u },
        #  { minimum: 1, gender: Male, division: Open }]
        # Or a Father/Son would be:
        # [{ minimum: 1, gender: Male, division: 14u },
        #  { minimum: 1, gender: Male, division: Open }]
        # These can display manually in title & fully on the tournament page
        # TODO UI must make it clear when a tournament is competitive or rec
        requirements: array<tuple<minimum: int16, gender: Gender, division: Division>>;
        index on (exists .requirements);
        constraint expression on (
            exists .requirements or (.gender != Gender.Coed and .team_size = 2)
        );

        # tags: array<TournamentTag>;
        # TODO proper index
        # index on (contains(.tags, TournamentTag.TourStop))

        # This allows for the tournament to be full when autopromote is disabled
        required full: bool {
            default := false;
        }
        required beach -> Beach;
        required multi directors -> DirectorPreferences {
            rank: int16;
        }

        required pools_public: bool {
            default := false;
        }

        # required fee: float32; # Cost per team to enter
        # # How much the office gets per team, in flat amount
        # # Used by financial overview for TD, admin
        # required office_cut: float32 {
        #     default := 15;
        # }

        # If null, uses schedule version (TODO), then beach
        directions: str {
            constraint min_len_value(5);
            constraint max_len_value(2500);
        }
        description: str {
            constraint min_len_value(5);
            constraint max_len_value(6000);
        }

        # -1 for half
        # 0 for never (or per set if match)
        # 7 for (every 7 for 21+ / every 5 for less)
        # Other numbers for that number
        # UI displays Standard (default), Half, Never, Other (input)
        # required side_switch: int16 {
        #     default := 7;
        # }

        required max_teams: int16 {
            default := 10;
        }
        required max_waitlist: int16 {
            default := 5;
        }
        required autopromote_wl: bool {
            default := true;
        }

        # Bitmap encoding 4 bit warmup, 4 bit timeout (2x), 3 bit technical, 1 bit medical
        # Warmup: 2.5m per, 10m base, starts the moment previous game ends
        # Timeout: 30 seconds per
        # Technical: 0, 30, 60, 90, 120, 180, 240, 300
        # Medical: Kinda whatever, could even drop a bit
        # required durations: int16 {
        #     # 0010 warmup for 10 + 5 mins between games
        #     # 0010 timeout 1, 2 = 1 min
        #     # 0000 timeout 2, none
        #     # 010  technical, 2 = 1 min
        #     # 1    medical 5 min medical
        #     # 0010001000000101
        #     default := 8709;
        # }
        # required photo -> Photo;

        # Backend hardcoded +time from tournament for first, second eligible
        # Should send email to players, coaches when about to expire
        # With link to both qualifier and main tournament
        # Qualifier tournament has pass UI (with confirmation modal)
        # Main tournament has buttons to pass or register that prefills the team
        # And passes along metadata of which qualifier to claim, passes on others for both players
        # Could also ignore pass UI, not like they would ever use it
        # Multiple rows if multiple eligibilities

        # I debated making this a multi property but no immediate use
        # Decent increase in complexity esp UI
        # But easy enough to add later if needed
        # qualifier_for -> Tournament {
        #     # Is default -time from Cal Cup or +time from tournament?
        #     # Maybe a setting on the target tournament
        #     # Also admin editable
        #     expires_at: datetime;
        #     finish_eligible: int16;
        # }

        # Probably just do both players invited separately, only invited eligible
        # TD can sort it out if they somehow make the wrong team
        # Also allows more generic form where they can choose any partner
        multi invited -> User;

        # Defaults are stored on TDs?
        # Global defaults?
        # multi withdrawal_rules -> WithdrawalRule;
    }

    scalar type TeamStatus extending enum<
        Active,

        # No withdraw fees
        # Full refund to wallet when tournament starts
        # Can be solo due to signing up to waitlist while solo
        Waitlisted,

        # Terminal statuses
        # These states cannot be changed - team has to sign up again
        # Except forfeit can go abandoned ref/ejected?
        # UI needs a lot of confirms around this
        # Unless denoted as inactive, teams are still "active"
        # Are shown in list of teams, are in pools
        # They just don't have / won't have more games
        # May have a section showing inactive teams

        Transferred, # Inactive status

        # Set by user withdrawal (until noon day before)
        # Creates appropriate wallet refunds minus fees
        Withdrawn, # Inactive status

        # Score history stays for games already played or in progress
        # If playoffs, handles like a loss
        # If pool, calculates them as full losses
        # If somehow still put to playoffs (eg small tournament)
        # Make sure # playoff teams is actually min(# teams, # playoffs teams)
        # Also important in case TD sets number higher than signups (also no shows)
        # Can be set by either TD or team
        Forfeited,

        # Manually set by TD
        AbandonedRef,
        Ejected, # Similar to Forfeit but displays different
        # Inactive statuses. No refund.
        LateWithdrawn,
        NoShowed,
    >;

    type Team extending HasCreated {
        # TODO drop after migrations
        legacy_id: int32 {
            constraint exclusive;
        }
        legacy_payment_id: int32;

        # Basically just a url slug.
        required url: str {
            readonly := true;
            constraint exclusive;
            constraint min_len_value(8);
            constraint max_len_value(8);
            rewrite insert using (
                with letters := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'
                select to_str(array_agg((for _ in range_unpack(range(0, 8)) union (
                        letters[<int64>math::floor(random() * 1000 % len(letters))])
                    )), '')
            );
        }

        # Transaction key from usaepay
        # LEGACY for teams prior to migration
        # ADMIN:id for td/admin override pay
        required transaction_key: str;

        # Changing players is allowed until pools are public
        # If change after that is needed TD can do it
        multi players -> User {
            # Current values set at time of tournament start
            # Before start uses directly from User
            rating: Rating;
            points: float32; # Rated/junior depending on division
            rank: int32;
            checked_in: bool;
            note: str {
                constraint max_len_value(500);
            }
        }
        # Purchaser is duplicated into here from purchase
        # TODO trigger for adding that
        # They can theoretically be removed & simplifies query
        # UI elements to add, remove people if needed
        multi can_edit -> User;
        # "Transfer" registration is actually withdraw -> reregister
        required tournament -> Tournament {
            readonly := true;
        }
        # TODO constraint appropriate TerminalStatus exists
        # TODO trigger assert cannot change once terminal
        required status: TeamStatus;
        index on (.status);


        # Position on waitlist if status is waitlist
        # Null if other inactive status
        # TODO constraint for that
        seed: int16;
        pool -> Pool;
        pool_seed: int16; # May not be in same order as seed, eg late join

        finish: int16;
        points_earned: float32; # Juniors vs rated points from tournament type
        rating_earned: Rating;

        # trigger active after insert, update for each do (
        #     assert(__new__.status = TeamStatus.Withdrawn or
        #     __new__.tournament.status = TournamentStatus.Complete or
        #     __new__.players.active,
        #     message := 'Invalid player membership')
        # );

        # trigger team_size after insert, update for each do (
        #     assert(__new__.status = TeamStatus.Withdrawn or
        #     __new__.tournament.status = TournamentStatus.Complete or
        #     count(__new__.players) = __new__.tournament.team_size,
        #     message := 'Invalid team size')
        # );

        # trigger gender after insert, update for each do (
        #     assert(__new__.tournament.status = TournamentStatus.Complete or
        #         __new__.tournament.gender = Gender.Coed or
        #         __new__.players.gender = __new__.tournament.gender,
        #     message := 'Invalid player gender')
        # );

        # trigger juniors after insert, update for each do (
        #     assert((with
        #         d := __new__.tournament.division,
        #         diff := 0 if d = Division.U18 else
        #                 2 if d = Division.U16 else
        #                 4 if d = Division.U14 else
        #                 6 if d = Division.U12 else
        #                 -10000,
        #         sept_diff := 1 if datetime_get(__new__.tournament.start_at, 'month') > 8 else 0
        #         select __new__.status = TeamStatus.Withdrawn or
        #         __new__.tournament.status = TournamentStatus.Complete or
        #         exists __new__.tournament.requirements or
        #         d in {
        #             Division.Open,
        #             Division.AAA,
        #             Division.AA,
        #             Division.A,
        #             Division.B,
        #             Division.Unrated,
        #         } or
        #         datetime_get(__new__.tournament.start_at, 'year') + diff + sept_diff <= (__new__.players.high_school_grad_year ?? 0)),
        #     message := 'Invalid player age')
        # );

        # trigger rated after insert, update for each do (
        #     assert((with
        #         d := __new__.tournament.division,
        #         rs := __new__.players.rating
        #         select __new__.status = TeamStatus.Withdrawn or
        #         __new__.tournament.status = TournamentStatus.Complete or
        #         d in {
        #             Division.Open,
        #             Division.AAA,
        #             Division.U18,
        #             Division.U16,
        #             Division.U14,
        #             Division.U12,
        #         } or
        #         (rs not in { Rating.AAA } if d = Division.AA else
        #         rs not in { Rating.AAA, Rating.AA } if d = Division.A else
        #         rs not in { Rating.AAA, Rating.AA, Rating.A } if d = Division.B else
        #         rs not in { Rating.AAA, Rating.AA, Rating.A, Rating.B })),
        #     message := 'Invalid player rating')
        # );

        # trigger full_status_check after insert for each do (
        #     with cnt := count((
        #         select __new__.tournament.<tournament[is Team]
        #         filter .status = TeamStatus.Active
        #     )),
        #     update __new__.tournament set {
        #         full := (cnt >= .max_teams) and
        #         assert(cnt <= .max_teams, message := 'Tournament Full') and
        #         assert(.status in { TournamentStatus.RosterPublic, TournamentStatus.RosterPrivate } and
        #                .registration in { RegistrationStatus.Open, RegistrationStatus.Test },
        #                message := 'Invalid tournament status')
        #     }
        # );

        trigger set_tournament_full after insert for each do (
            with cnt := count((
                select __new__.tournament.<tournament[is Team]
                filter .status = TeamStatus.Active
            )),
            update __new__.tournament set {
                full := (cnt >= .max_teams)
            }
        );
    }

    type TeamPlayerChanged extending HasCreated {
        required team -> Team {
            readonly := true;
        }
        required multi old -> User {
            readonly := true;
            on target delete delete source;
        }
        required multi new -> User {
            readonly := true;
            on target delete delete source;
        }
        required editor -> User {
            readonly := true;
            on target delete delete source;
        }
    }

    type Pool {
        # Let's have some fun
        # Take various alphabetical word lists
        # So can shorten to Pool A-F whatever
        # But display as full name
        required name: str;
        # index on (.name);
        required tournament -> Tournament {
            readonly := true;
        }
        court: str {
            constraint max_len_value(50);
            rewrite insert, update using (str_trim(.court, '.:/- '));
        }
        # Teams are implicit via series
        # Ranking calculated on the fly?
        # Or via fields that are calculated via trigger?

        # Courts are implicit via series
        # Logic for 6+ team pools on multiple courts in frontend
        # Large pools are rare, will just do its best, TD can override

        # Pool play shows in seed order until done
        # Still keeps original seed, order calculated in frontend
        # TODO constraint that if true,
        # No games in this pool have contested
        # All games have an end time
        required done: bool {
            default := false;
        }

        constraint exclusive on ((.name, .tournament))
    }

    abstract type MatchNumber {
        required match_number: int16;
        team_a -> Team;
        team_b -> Team;
        # If manually set by TD/admin can be user
        # Phil can access score independently of this, if enabled
        multi refs -> User {
            scorekeeper: bool;
            # constraint exclusive on ((@source, @scorekeeper));
        }

        court: str {
            constraint max_len_value(50);
            rewrite insert, update using (str_trim(.court, '.:/- '));
        }

        # If not set uses what tournament has. See bitmap on tournament.
        # Between sets in a match is always 5 mins
        # durations: int16;
    }

    type PoolMatch extending MatchNumber {
        overloaded required team_a -> Team;
        overloaded required team_b -> Team;

        required pool -> Pool {
            readonly := true;
        }

        # index on (.match_number);
        constraint exclusive on ((.match_number, .pool))
    }

    type PlayoffMatch extending MatchNumber {
        required tournament -> Tournament {
            readonly := true;
        }

        # TODO change this to a single multi link with constraints
        a_from -> PlayoffMatch | Pool {
            rank: int16;
        }
        b_from -> PlayoffMatch | Pool {
            rank: int16;
        }
        # multi teams_from: PlayoffMatch | Pool {
        #     rank: int16;
        #     # constraint exclusive on((@target, @rank));
        #     side: PlayoffSide;
        #     constraint expression on (@side ?= PlayoffSide.A or @side ?= PlayoffSide.B);
        #     # constraint exclusive on ((@source, @side));
        # }

        # Doesn't work, can't use agg functions
        # constraint expression on (count(.teams_from) <= 2);

        ref_from -> PlayoffMatch;

        constraint exclusive on ((.match_number, .tournament));
    }

    # Can't be called Set because reserved :(
    type MatchSet {
        required for_match -> MatchNumber {
            readonly := true;
        }
        required set_number: int16;
        # index on (.set_number);
        started_at: datetime;
        ended_at: datetime;
        # required service -> int32 {
        #     # Bitmap encoding initial order, next serve
        #     default := 0;
        # }
        required win_score: int16;
        score: bytes; # History bitmap, score calculated on frontend
        # Bitmap again, with point taken, duration
        # Up to 8 times to track - warmup, 2x normal, 2x medical, technical
        # Team is a bit
        # Score taken at is 7 bits
        # Type of timeout is 2 bits
        # If 2 bytes, leaves 6 bits
        # Probably just add a byte and use 14 bits to track to the second
        # Maybe on series?
        # Probably a total stretch goal for now
        # required timeouts: bytes;

        constraint exclusive on ((.set_number, .for_match));
    }

    type Invite extending HasCreated {
        required multi tournament -> Tournament;
        # One or more players
        # If a player is specified, they must be on the team
        required multi players -> User;

        source_tournament -> Tournament
    }

    type Faq {
        required question: str;
        required answer: str;
    }

    scalar type OptInService extending enum<ConstantContact>;

    type OptIn extending HasCreated {
      required user: User;
      required service: OptInService;
      required committed: bool {
        default := false;
      }
      constraint exclusive on ((.user, .service))
    }

    type ConstantContactContact extending HasCreated {
      required user: User;
      required list_memberships: array<uuid>;

      # If different than .user.email, contant contact needs updated
      required email: str;

      # Populated once created via the api
      constant_contact_id: uuid;

      constraint exclusive on (.user)
    }

    type VblPublication {
      required tournament: Tournament;

      required published: bool {
        default := false
      }

      created: datetime {
        rewrite insert using (datetime_of_statement())
      }
      modified: datetime {
        rewrite update using (datetime_of_statement())
      }
    }
}
